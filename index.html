<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>image3dW v0.6.0</title>
	<style>body { margin:0; overflow:hidden; }</style>
	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/keyboard.js"></script>
	<script src="js/mouse.js"></script>
</head>
<body>
	<div id="controlPanel">
		f<sub>m</sub> (Hz)
		<input id="frequencyM" type="number" style="width:40px" oninput="frequencyM = this.value" step="1" onwheel=" frequencyM = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		d<sub style="color:red;">x</sub>
		<input id="amplitude_x" type="number" style="width:40px" oninput="amplitude_x = this.value" step=".1" onwheel="amplitude_x = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>
		d<sub style="color:limeGreen;">y</sub>
		<input id="amplitude_y" type="number" style="width:40px" oninput="amplitude_y = this.value" step=".1" onwheel="amplitude_y = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>
		d<sub style="color:blue;">z</sub>
		<input id="amplitude_z" type="number" style="width:40px" oninput="amplitude_z = this.value" step=".1" onwheel="amplitude_z = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>			
		Œ∏<sub style="color:blue;">z</sub>
		<input id="rotation_z" type="number" style="width:40px" oninput="rotation_z = mesh.rotation.z = this.value/180*Math.PI" step="5" onwheel="rotation_z = mesh.rotation.z = this.value/180*Math.PI=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>
		‚Üî<input id="flip_horizontal" type="checkbox" oninput="mesh.scale.x *=-1"/>
		‚Üï<input id="flip_vertical" type="checkbox" oninput="mesh.scale.y *=-1"/>	
		‚ò∞<input id="grid" type="checkbox" oninput="gridHelper.visible = !gridHelper.visible"/>	
		f<sub>r</sub> (Hz)
		<input id="frequencyR" type="number" style="width:40px" oninput="frequencyR = this.value" step="1" onwheel=" frequencyR = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		r<sub style="color:red;">x</sub>
		<input id="theta_x" type="number" style="width:40px" oninput="theta_x = this.value" onwheel="theta_x = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>
		r<sub style="color:limeGreen;">y</sub>
		<input id="theta_y" type="number" style="width:40px" oninput="theta_y = this.value" onwheel="theta_y = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>
		r<sub style="color:blue;">z</sub>
		<input id="theta_z" type="number" style="width:40px" oninput="theta_z = this.value" onwheel="theta_z = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>			
		œÜ<sub style="color:red;">x</sub>
		<input id="phase_x" type="number" style="width:40px" oninput="phase_x = this.value" step="90" onwheel="phase_x = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		œÜ<sub style="color:limeGreen;">y</sub>
		<input id="phase_y" type="number" style="width:40px" oninput="phase_y = this.value" step="90" onwheel="phase_y= this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		œÜ<sub style="color:blue;">z</sub>
		<input id="phase_z" type="number" style="width:40px" oninput="phase_z = this.value" step="90" onwheel="phase_z = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		h
		<input id="height2" type="number" style="width:40px" oninput="height2 = this.value" onwheel="height2 = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)"/>
		
		d<sub>z</sub>
		<input id="distance_z" type="number" style="width:40px" oninput="distance_z = parseFloat(this.value)" step="1" onwheel="distance_z = this.value = parseFloat(this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		p<sub>z</sub>
		<input id="pivot_z" type="number" style="width:40px" oninput="pivot_z = parseFloat(this.value)" step="1" onwheel="pivot_z = this.value = parseFloat(this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		
		‚à†
		<input id="perspective_angle" type="number" style="width:40px"  oninput=" camera.fov = this.value; camera.updateProjectionMatrix()"  step="5" onwheel="camera.fov = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step; camera.updateProjectionMatrix()"/>
		
		img
		<input type="file" id="imageInput" accept="image/jpeg, image/gif, image/bmp, image/webp" onchange="handleImageUpload(event)">
		depth</sub>
		<input type="file" id="depthInput" accept="image/png" onchange="handleDepthUpload(event)"><!--image/*-->
		
		<br>
		f<sub>w</sub> (Hz)
		<input id="frequencyW" type="number" style="width:40px" oninput="frequencyW = this.value" step="1" onwheel=" frequencyW = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		Œª
		<input id="wavelength" type="number" style="width:40px" oninput="wavelength = this.value" step="1" onwheel=" wavelength = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		w<sub>scale</sub>
		<input id="scaleW" type="number" style="width:40px" oninput="scaleW = this.value" step=".1" onwheel=" scaleW = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		w<sub style="color:red;">x</sub>
		<input id="w_x" type="number" style="width:40px" oninput="w_x = this.value" step="1" onwheel=" w_x = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		w<sub style="color:limeGreen;">y</sub>
		<input id="w_y" type="number" style="width:40px" oninput="w_y = this.value" step="1" onwheel=" w_y = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		w<sub style="color:blue;">z</sub>
		<input id="w_z" type="number" style="width:40px" oninput="w_z = this.value" step="1" onwheel=" w_z = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚åí<sup>near</sup>
		<input id="hNear" type="number" style="width:40px" oninput="hNear = this.value" step=".05" onwheel=" hNear = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚åí<sup>far</sup>
		<input id="hFar" type="number" style="width:40px" oninput="hFar = this.value" step=".05" onwheel=" hFar = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚åí<sup>ùëì</sup>
		<input id="steepness" type="number" style="width:40px" oninput="steepness = this.value" step="1" onwheel=" steepness = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
						
		d<sub style="color:grey;">depth</sub>
		<input id="brightnessDepth" type="number" style="width:40px" oninput="brightnessDepth = this.value" step=".1" onwheel=" brightnessDepth = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚à†<sub style="color:red;">x</sub><sub>depth</sub>
		<input id="theta_depth_x" type="number" style="width:40px" oninput="theta_depth_x = this.value" step="5" onwheel=" theta_depth_x = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚à†<sub style="color:green;">y</sub><sub>depth</sub>
		<input id="theta_depth_y" type="number" style="width:40px" oninput="theta_depth_y = this.value" step="5" onwheel=" theta_depth_y = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ≠<sub style="color:red;">x</sub><sub>1</sub>
		<input id="bx1" type="number" style="width:40px" oninput="bx1 = this.value" step=".1" onwheel=" bx1 = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ≠<sub style="color:green;">y</sub><sub>1</sub>
		<input id="by1" type="number" style="width:40px" oninput="by1 = this.value" step=".1" onwheel=" by1 = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ≠<sub style="color:red;">x</sub><sub>2</sub>
		<input id="bx2" type="number" style="width:40px" oninput="bx2 = this.value" step=".1" onwheel=" bx2 = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ≠<sub style="color:green;">y</sub><sub>2</sub>
		<input id="by2" type="number" style="width:40px" oninput="by2 = this.value" step=".1" onwheel=" by2 = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ≠<sub>ùëì</sub>
		<input id="steepnessB" type="number" style="width:40px" oninput="steepnessB = this.value" step=".1" onwheel=" steepnessB = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		<sub>baseFloor</sub>
		<input id="baseFloor" type="number" style="width:40px" oninput="baseFloor = this.value" step=".1" onwheel=" baseFloor = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ≠<sub>visible</sub><input id="boxVisible" type="checkbox" oninput="boxVisible =!boxVisible"/>	
		‚úÇ
		<input id="clippingPlane" type="number" style="width:40px" oninput="clippingPlane = this.value" step=".05" onwheel=" clippingPlane = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		k
		<input id="k_value" type="number" style="width:40px" oninput="k_value = this.value" step=".1" onwheel=" k_value = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		<br>
		‚òº
		<input id="brightness" type="number" style="width:40px" oninput="brightness = this.value" step=".05" onwheel=" brightness = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		contrast
		<input id="contrast" type="number" style="width:40px" oninput="contrast = this.value" step=".1" onwheel=" contrast = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		saturation
		<input id="saturation" type="number" style="width:40px" oninput="saturation = this.value" step=".1" onwheel=" saturation = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		background
		<input id="bg-color" type="text" style="width:80px" oninput="renderer.setClearColor(new THREE.Color(this.value), 1); // hex + alpha" placeholder="#000000"/>
		<button type="button" onClick="eyedropperMode=!eyedropperMode; changeCursor();" >eyedropper</button>
		width
		<input id="width-mesh" type="number" style="width:40px" oninput="rotationGroup.scale.x = this.value" step=".1" onwheel=" rotationGroup.scale.x = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		height
		<input id="height-mesh" type="number" style="width:40px" oninput="rotationGroup.scale.y = this.value" step=".1" onwheel=" rotationGroup.scale.y = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ±<sub style="color:red;">x</sub>
		<input id="sheerX" type="number" style="width:40px" oninput="sheerX = this.value" step=".1" onwheel=" sheerX = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		‚ñ±<sub style="color:green;">y</sub>
		<input id="sheerY" type="number" style="width:40px" oninput="sheerY = this.value" step=".1" onwheel=" sheerY = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		
		presets: 
		<select id="presetDropdown" onchange="reset(this.value)">
			<option value="presets/bounce.ini">Bounce</option>
			<option value="presets/shake.ini">Shake</option>
			<option value="presets/wobble.ini"selected>Wobble</option>
			<option value="presets/vibrate.ini">Vibrate</option>
			<option value="presets/turn.ini">Turn</option>
			<option value="presets/oscillate.ini">Oscillate</option>
			<option value="presets/sway.ini">Sway</option>
		</select>
		<button type="button" onClick="randomize()" >random</button>
		<button type="button" onClick="reset('config.ini')">‚Üª</button>
		subdivisions
		<input id="subdivisions" type="number" style="width:40px" oninput="subdivisions = this.value;setSubdivisions(this.value)" step="10" onwheel=" subdivisions = this.value=parseFloat (this.value)-event.deltaY/Math.abs(event.deltaY)*this.step"/>
		
	</div>
<!-- VERTEX SHADER -->
<script id="depthVertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
uniform sampler2D heightMap;
uniform float sFrequency;
uniform float sTime;
uniform float sHeight;
uniform float sWavelength;
uniform float w_x;
uniform float w_y;
uniform float w_z;
uniform float sPhase_x;
uniform float sPhase_y;
uniform float sPhase_z;
uniform float sComplexity;
uniform float sNear;
uniform float sFar;
uniform float sSteepness;
uniform float bx1;
uniform float by1;
uniform float bx2;
uniform float by2;
uniform float steepnessB;
uniform float baseFloor;

uniform float sheerX;
uniform float sheerY;
uniform float k_value;

uniform float sBrightnessDepth;
uniform float sBrightness;
uniform float sTheta_depth_x;
uniform float sTheta_depth_y;

const float PI = 3.14159265359;

varying float vXCoord;//for fragment shader
varying float vYCoord;//for fragment shader
varying float vZCoord;//for fragment shader

float gauss(float x, float close, float far, float multiplier){
	return exp(-pow( (x-((far+close)/2.0))/
								((close-far)/multiplier),2.0)
								);
}
// Returns a sine wave with controllable steepness.
// Set remapTo01 = true to get [0,1] range; false for [-1,1]
float steepSine(float x, float steepness) {
    float s = sin(x);
    
    // Remap from [-1,1] to [0,1]
    s = 0.5 * s + 0.5;

    // Apply power curve for steepness control
    s = pow(s, steepness);

    // Optional remap back to [-1,1]
    return s * 2.0 - 1.0;
}

void main() {
	vUv = uv;
	vec4 h2 = texture2D(heightMap, uv);
	h2.r += sTheta_depth_x*position.x/1000.0;
	h2.r += sTheta_depth_y*position.y/1000.0;
	
	//position.x += sheerX*position.y;
	//position.y += sheerY*position.x;
	
	float gaussian = max(gauss(h2.r,sNear,sFar,sSteepness),baseFloor);
	float gaussianX = max(gauss(position.x,bx1,bx2,steepnessB),baseFloor);
	float gaussianY = max(gauss(position.y,by1,by2,steepnessB),baseFloor);
	
	h2.r +=sBrightnessDepth;
	if(h2.r<0.0)
		h2.r = 0.0;
	
	if(h2.r>1.0)
		h2.r = 1.0;
	
	
	//vNormal = normalize(normalMatrix * normal);
	vec3 displacment = vec3(
								steepSine(h2.r*sWavelength-sTime*sFrequency+sPhase_x/360.0*2.0*PI,k_value)*w_x,
								steepSine(h2.r*sWavelength-sTime*sFrequency+sPhase_y/360.0*2.0*PI,k_value)*w_y,
								steepSine(h2.r*sWavelength-sTime*sFrequency+sPhase_z/360.0*2.0*PI,k_value)*w_z);
	vec3 displacedPosition = vec3(position.x+position.y*sheerX,position.y+position.x*sheerY,position.z) + (normal*  h2.r * sHeight +displacment*gaussian*gaussianX*gaussianY/100.0);
	
	vXCoord=position.x;//for fragment shader
	vYCoord=position.y;//for fragment shader
	vZCoord=displacedPosition.z;//for fragment shader
	
	gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
}
</script>

<!-- FRAGMENT SHADER -->
<script id="depthFragmentShader" type="x-shader/x-fragment">
varying vec2 vUv;
uniform sampler2D diffuseMap;
uniform float sBrightness;
uniform float sContrast;
uniform float sSaturation;
uniform bool boxVisible;
uniform float sHeight;
//box
uniform float bx1;
uniform float by1;
uniform float bx2;
uniform float by2;

uniform float sNear;
uniform float sFar;
uniform float sBrightnessDepth;

uniform float clippingPlane;

precision mediump float;
varying float vXCoord;
varying float vYCoord;
varying float vZCoord;


void main() {
	vec3 color = texture2D(diffuseMap, vUv).rgb;
	float alpha = 1.0;
	// Adjust brightness
	color.rgb += sBrightness;
	// Adjust contrast
	color.rgb = (color.rgb - 0.5) * sContrast + 0.5;
	// Saturation
	float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114)); // perceptual luminance
	color.rgb = mix(vec3(gray), color.rgb, sSaturation);
	
	//box
	if(boxVisible){
		float epsilon = 0.01;
		if (abs(vXCoord - bx1) < epsilon)
			color = vec3(1.0, 0.0, 0.0); // highlight
		if (abs(vXCoord - bx2) < epsilon)
			color = vec3(1.0, 1.0, 0.0); // highlight
		if (abs(vYCoord - by1) < epsilon)
			color = vec3(0.0, 1.0, 0.0); // highlight
		if (abs(vYCoord - by2) < epsilon)
			color = vec3(0.0, 1.0, 1.0); // highlight
		if (abs(vZCoord - (sNear+sBrightnessDepth)*(sHeight)) < epsilon)
			color = vec3(0.0, 0.0, 1.0); // highlight
		if (abs(vZCoord - (sFar+sBrightnessDepth)*(sHeight)) < epsilon)
			color = vec3(1.0, 0.0, 1.0); // highlight
	}
	if(vZCoord<clippingPlane*sHeight)
		alpha = 0.0;
	gl_FragColor = vec4(color, alpha);
}
</script>

<script>


const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 60, innerWidth / innerHeight, 0.1, 100 );
const renderTarget = new THREE.WebGLRenderTarget(
  window.innerWidth * window.devicePixelRatio,
  window.innerHeight * window.devicePixelRatio
);
	
camera.position.set(0,0,20);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

//Load orbit controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; // smooth camera motion

//Grid
const gridSize = 100;
const gridDivisions = 10;
const gridHelper = new THREE.GridHelper(gridSize, gridDivisions);
scene.add(gridHelper);
gridHelper.visible = false;

//gaussian box
var boxVisible = false;

//Mesh Rotation
var rotationGroup = new THREE.Group();
var rotationPoint = new THREE.Vector3(0, 0, 0);
rotationGroup.position.copy(rotationPoint);
var pivot_z = 0;

var sheerX = 0;
var sheerY = 0;

var material = null;
var mesh = null;
var geometry = null;
var tex = null;
// Load both height map and diffuse map
const loader = new THREE.TextureLoader();
animate();
function handleImageUpload(event) {
	const file = event.target.files[0];
	if (!file) return;
	const reader = new FileReader();
	reader.onload = function (e) {
		const imageURL = e.target.result;

		new THREE.TextureLoader().load(imageURL, function (texture) {
			texture.needsUpdate = true;

			tex = texture;
			const uniforms = {
				sTime: { value: 0.0 },
				sHeight: { value: 13.0 },
				sWavelength: { value: 10.0 },
				w_x: { value: 1.0 },
				w_y: { value: 1.0 },
				w_z: { value: 1.0 },
				sPhase_x: { value: 1.0 },
				sPhase_y: { value: 1.0 },
				sPhase_z: { value: 1.0 },
				sFrequency: { value: 1.0 },
				sComplexity: { value: 1.0 },
				diffuseMap: { value: texture },
				sNear: {value: 0.0},
				sFar: {value: 0.0},
				sTheta_depth_x: {value: 1.0},
				sTheta_depth_y: {value: 1.0},
				sSteepness: {value: 0.0},
				heightMap: { value: texture }, // Use same if you want
				sBrightness: {value: 0.0},
				sBrightnessDepth: {value: 0.0},
				sContrast: {value: 0.0},
				sSaturation: {value: 0.0},
				bx1: {value: 0.0},
				bx2: {value: 0.0},
				by1: {value: 0.0},
				by2: {value: 0.0},
				sheerX: {value: 0.0},
				sheerY: {value: 0.0},
				k_value: { value: 0.0 },
				steepnessB: { value: 0.0 },
				clippingPlane: { value: 0.0 },
				baseFloor: { value: 0.0 },				
				boxVisible: { value: false }
			};

			material = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: document.getElementById('depthVertexShader').textContent,
				fragmentShader: document.getElementById('depthFragmentShader').textContent,
				transparent: true
			});

			geometry = new THREE.PlaneGeometry(
				texture.image.width/100,
				texture.image.height/100,
				texture.image.width/3,
				texture.image.height/3
			);
			removeMeshFromScene(mesh);
			mesh = new THREE.Mesh(geometry, material);
			//scene.add(mesh);
			rotationGroup.add(mesh);
			scene.add(rotationGroup);
		});
	};

	reader.readAsDataURL(file);
}
function setSubdivisions(n) {
	if (!tex) return; // texture must be loaded first

	// Dispose of old geometry if it exists
	if (geometry) geometry.dispose();

	// Create new geometry with n subdivisions
	geometry = new THREE.PlaneGeometry(
		tex.image.width / 100,
		tex.image.height / 100,
		n,
		n
	);

	// Update mesh geometry
	if (mesh) {
		mesh.geometry = geometry;
	}
}
function removeMeshFromScene(mesh) {
	if (!mesh) return;

	// Remove from parent/scene
	if (mesh.parent) {
		mesh.parent.remove(mesh);
	}

	// Dispose geometry
	if (mesh.geometry) {
		mesh.geometry.dispose();
	}

	// Dispose material(s)
	if (Array.isArray(mesh.material)) {
		mesh.material.forEach(mat => {
			disposeMaterial(mat);
		});
	} else if (mesh.material) {
		disposeMaterial(mesh.material);
	}
}

function disposeMaterial(material) {
	// Dispose textures if present
	for (const key in material) {
		const value = material[key];
		if (value && value.isTexture) {
			value.dispose();
		}
	}

	material.dispose();
}
function handleDepthUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const imageURL = URL.createObjectURL(file);
        
        loader.load(
            imageURL,
            function (texture) {
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;

                console.log("Texture loaded:", texture);
                // Use the texture (e.g. apply it to a mesh)
                material.uniforms.heightMap.value = texture;
            },
            undefined,
            function (err) {
                console.error("Error loading texture:", err);
            }
        );
    }
}
let scaleW = 1;
document.getElementById('scaleW').value = 1;

let clock = new THREE.Clock();
function animate(time) {
	if(mesh!=null){
		//position oscilation
		mesh.position.x = Math.sin(frequencyM*time/1000.0 +phase_x/360*2*Math.PI)*amplitude_x; 
		mesh.position.y = Math.sin(frequencyM*time/1000.0+phase_y/360*2*Math.PI)*amplitude_y; 
		mesh.position.z = pivot_z + Math.sin(frequencyM*time/1000.0 +phase_z/360*2*Math.PI)*amplitude_z; 		
		//rotation oscilation
		rotationGroup.rotation.x = theta_x/360.0*Math.PI *Math.sin(frequencyR*time/1000.0 +phase_x/360*2*Math.PI);
		rotationGroup.rotation.y = theta_y/360.0*Math.PI *Math.sin(frequencyR*time/1000.0 +phase_y/360*2*Math.PI);
		rotationGroup.rotation.z = theta_z/360.0*Math.PI *Math.sin(frequencyR*time/1000.0 +phase_z/360*2*Math.PI);
		rotationGroup.position.z = distance_z;
		//shader variables
		material.uniforms.sTime.value = time / 1000;		
		material.uniforms.sHeight.value = height2;
		material.uniforms.sWavelength.value = wavelength;
		material.uniforms.w_x.value = w_x*scaleW;
		material.uniforms.w_y.value = w_y*scaleW;
		material.uniforms.w_z.value = w_z*scaleW;
		material.uniforms.sPhase_x.value = phase_x;
		material.uniforms.sPhase_y.value = phase_y;
		material.uniforms.sPhase_z.value = phase_z;
		material.uniforms.sNear.value = hNear;
		material.uniforms.sFar.value = hFar;
		material.uniforms.sSteepness.value = steepness;
		material.uniforms.sFrequency.value = frequencyW;
		material.uniforms.sBrightness.value = brightness;
		material.uniforms.sContrast.value = contrast;
		material.uniforms.sSaturation.value = saturation;
		material.uniforms.sBrightnessDepth.value = brightnessDepth;
		material.uniforms.sTheta_depth_x.value = theta_depth_x;
		material.uniforms.sTheta_depth_y.value = theta_depth_y;
		material.uniforms.bx1.value = bx1;
		material.uniforms.bx2.value = bx2;
		material.uniforms.by1.value = by1;
		material.uniforms.by2.value = by2;
		material.uniforms.steepnessB.value = steepnessB;
		material.uniforms.boxVisible.value = boxVisible;
		material.uniforms.clippingPlane.value = clippingPlane;
		material.uniforms.baseFloor.value = baseFloor;
		material.uniforms.sheerX.value = sheerX;
		material.uniforms.sheerY.value = sheerY;
		material.uniforms.k_value.value = k_value;
	}
	requestAnimationFrame(animate);
	controls.update(); // required for damping or auto-rotate
	// Render to offscreen render target (for picking)
	renderer.setRenderTarget(renderTarget);
	renderer.render(scene, camera);

	// Now render to screen (so user sees it)
	renderer.setRenderTarget(null);
	renderer.render(scene, camera); // <- This was missing
}
reset("config.ini");
window.addEventListener('resize', () => {
	const newWidth = window.innerWidth;
	const newHeight = window.innerHeight;
	camera.aspect = newWidth / newHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(newWidth, newHeight);
	renderTarget.setSize(newWidth, newHeight);
});
function reset(preset)
{
	fetch(preset)
	.then(response => response.text())
	.then(text => {
		const config = parseINI(text);
		//no override
		if(preset == 'config.ini')
		{
			scaleW= 1;
			document.getElementById("brightnessDepth").value = brightnessDepth = parseFloat(config.settings.brightnessDepth);
			document.getElementById("height2").value = height2 = parseFloat(config.settings.height2);

			document.getElementById("steepness").value = steepness = parseFloat(config.settings.steepness);
			document.getElementById("hNear").value = hNear = parseFloat(config.settings.hNear);
			document.getElementById("hFar").value = hFar = parseFloat(config.settings.hFar);
			
			document.getElementById("subdivisions").value = subdivisions = parseFloat(config.settings.subdivisions);
		
			document.getElementById("theta_depth_x").value = theta_depth_x = parseFloat(config.settings.theta_depth_x);
			document.getElementById("theta_depth_y").value = theta_depth_y = parseFloat(config.settings.theta_depth_y);
			
			document.getElementById("perspective_angle").value = perspective_angle = parseFloat(config.settings.perspective_angle);
			camera_z = parseFloat(config.settings.camera_z);
						
			document.getElementById("brightness").value = brightness = parseFloat(config.settings.brightness);
			
			document.getElementById("contrast").value = contrast = parseFloat(config.settings.contrast);
			document.getElementById("saturation").value = saturation = parseFloat(config.settings.saturation);
			
			document.getElementById("distance_z").value = distance_z = parseFloat(config.settings.distance_z);
			
			document.getElementById("bx1").value = bx1 = parseFloat(config.settings.bx1);
			document.getElementById("bx2").value = bx2 = parseFloat(config.settings.bx2);
			document.getElementById("by1").value = by1 = parseFloat(config.settings.by1);
			document.getElementById("by2").value = by2 = parseFloat(config.settings.by2);
			document.getElementById("steepnessB").value = steepnessB = parseFloat(config.settings.steepnessB);
			boxVisible = false;
			document.getElementById("clippingPlane").value = clippingPlane =0;
			document.getElementById("pivot_z").value = rotationPoint.z;
			document.getElementById("baseFloor").value = baseFloor = 0;
			
			document.getElementById("sheerX").value = sheerX = 0;
			document.getElementById("sheerY").value = sheerY = 0;
			document.getElementById("k_value").value = k_value = 1;
			 
		}
		document.getElementById("frequencyM").value = frequencyM = parseFloat(config.settings.frequencyM);
		document.getElementById("wavelength").value = wavelength = parseFloat(config.settings.wavelength);
		document.getElementById("w_x").value = w_x = parseFloat(config.settings.w_x);
		document.getElementById("w_y").value = w_y = parseFloat(config.settings.w_y);
		document.getElementById("w_z").value = w_z = parseFloat(config.settings.w_z);
		
		document.getElementById("rotation_z").value = rotation_z = parseFloat(config.settings.rotation_z);

		document.getElementById("frequencyR").value = frequencyR = parseFloat(config.settings.frequencyR);
		document.getElementById("theta_x").value = theta_x = parseFloat(config.settings.theta_x);
		document.getElementById("theta_y").value = theta_y = parseFloat(config.settings.theta_y);
		document.getElementById("theta_z").value = theta_z = parseFloat(config.settings.theta_z);
		document.getElementById("phase_x").value = phase_x = parseFloat(config.settings.phase_x);
		document.getElementById("phase_y").value = phase_y = parseFloat(config.settings.phase_y);
		document.getElementById("phase_z").value = phase_z = parseFloat(config.settings.phase_z);
		
		document.getElementById("amplitude_x").value = amplitude_x = parseFloat(config.settings.amplitude_x);
		document.getElementById("amplitude_y").value = amplitude_y = parseFloat(config.settings.amplitude_y);
		document.getElementById("amplitude_z").value = amplitude_z = parseFloat(config.settings.amplitude_z);
		
		document.getElementById("frequencyW").value = frequencyW = parseFloat(config.settings.frequencyW);
		
		
	})
	.catch(error => console.error('Error loading config.ini:', error));
}
function getRandom(value)
{
	return Math.random()*value*2-value;
}
function randomize()
{
	let max = 40;
	document.getElementById("frequencyW").value = frequencyW = getRandom(max/2);
	document.getElementById("wavelength").value = wavelength = getRandom(max);
	document.getElementById("w_x").value = w_x = getRandom(max);
	document.getElementById("w_y").value = w_y = getRandom(max);
	document.getElementById("w_z").value = w_z = getRandom(max);
	document.getElementById("phase_x").value = phase_x = getRandom(360);
	document.getElementById("phase_y").value = phase_y = getRandom(360);
	document.getElementById("phase_z").value = phase_z = getRandom(360);
}
function parseINI(text) {
  const result = {};
  let section = null;

  text.split(/\r?\n/).forEach(line => {
    line = line.trim();
    if (!line || line.startsWith(';') || line.startsWith('#')) return;

    if (line.startsWith('[') && line.endsWith(']')) {
      section = line.slice(1, -1).trim();
      result[section] = {};
    } else {
      const [key, value] = line.split('=');
      if (section) {
        result[section][key.trim()] = value.trim();
      } else {
        result[key.trim()] = value.trim();
      }
    }
  });

  return result;
}
</script>
</body>
</html>